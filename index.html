<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <style>
    html, body {
      margin: 0; /* remove the default margin          */
      height: 100%; /* make the html,body fill the page   */
    }

    canvas {
      display: block; /* make the canvas act like a block   */
      width: 100%; /* make the canvas fill its container */
      height: 100%;
    }
  </style>
</head>
<body>
<canvas></canvas>
<script>
  async function main() {
    const adapter = await navigator.gpu?.requestAdapter();
    const device = await adapter?.requestDevice();
    if (!device) {
      fail('need a browser that supports WebGPU');
      return;
    }

    const rand = (min, max) => {
      if (min === undefined) {
        min = 0;
        max = 1;
      } else if (max === undefined) {
        max = min;
        min = 0;
      }
      return min + Math.random() * (max - min);
    };


    const canvas = document.querySelector('canvas');
    const context = canvas.getContext('webgpu');
    const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
    context.configure({
      device,
      format: presentationFormat,
    });

    const module = device.createShaderModule({
      label: 'our hardcoded red triangle shaders',
      code: `
              struct VertexOutput {
                @builtin(position) position: vec4f,
                @location(0) color: vec4f,
              };

              struct Attributes {
                offset: vec2f,
                scale: vec2f
              };

              struct Vertex {
                 position: vec2f,
              };

              @group(0) @binding(0) var<storage, read> attributes: array<Attributes>;
              @group(0) @binding(1) var<storage, read> pos: array<Vertex>;

              @vertex fn vs(
                @builtin(vertex_index) vertexIndex : u32,
                @builtin(instance_index) instanceIndex: u32
              ) -> VertexOutput {

                let color = array<vec4f, 3>(
                   vec4f(1 ,0, 0, 1),
                   vec4f(0 ,1, 0, 1),
                   vec4f(0 ,0, 1, 1),
                );

                let attributed= attributes[instanceIndex];

                var vsOutput : VertexOutput;
                vsOutput.position = vec4(pos[vertexIndex].position * attributed.scale + attributed.offset, 0.0, 1.0);
                vsOutput.color = color[vertexIndex];

                return vsOutput;
              }

              @fragment fn fs(@builtin(position) pixelPosition: vec4f) -> @location(0) vec4f {
                 let red = vec4f(1, 0, 0, 1);
        let cyan = vec4f(0, 1, 1, 1);


        let grid = vec2u(pixelPosition.xy) / 8;
        let checker = (grid.x + grid.y) % 2 == 1;

        return select(red, cyan, checker);
              }
            `,
    });

    const pipeline = device.createRenderPipeline({
      label: 'our hardcoded red triangle pipeline',
      layout: 'auto',
      vertex: {
        module,
        entryPoint: 'vs',
      },
      fragment: {
        module,
        entryPoint: 'fs',
        targets: [{format: presentationFormat}],
      },
    });


    const scaleSize = .5;
    const objectInfos = new Float32Array([
      rand(), rand(),
      scaleSize, scaleSize,
      rand(), rand(),
      scaleSize, scaleSize,
    ]);


    const storageBuffer = device.createBuffer({
      label: 'storage buffer',
      size: objectInfos.byteLength,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });

    device.queue.writeBuffer(storageBuffer, 0, objectInfos);


    const triangleVertices = new Float32Array([
      0.0, 0.5,
      -0.5, -0.5,
      0.5, -0.5
    ]);

    const triangleBuffer = device.createBuffer({
      label: 'storage buffer',
      size: triangleVertices.byteLength,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });

    device.queue.writeBuffer(triangleBuffer, 0, triangleVertices);


    const bindGroup = device.createBindGroup({
      label: 'triangle bind group',
      layout: pipeline.getBindGroupLayout(0),
      entries: [
        {
          binding: 0,
          resource: {
            buffer: storageBuffer
          }
        },
        {
          binding: 1,
          resource: {
            buffer: triangleBuffer
          }
        }
      ],
    });

    const renderPassDescriptor = {
      label: 'our basic canvas renderPass',
      colorAttachments: [
        {
          clearValue: [0.3, 0.3, 0.3, 1],
          loadOp: 'clear',
          storeOp: 'store',
        },
      ],
    };

    const observer = new ResizeObserver(entries => {
      for (const entry of entries) {
        canvasToSizeMap.set(entry.target, {
          width: entry.contentBoxSize[0].inlineSize,
          height: entry.contentBoxSize[0].blockSize,
        });
      }
      render();
    });
    observer.observe(canvas);


    const canvasToSizeMap = new WeakMap();

    function resizeCanvasToDisplaySize(canvas) {
      // Get the canvas's current display size

      let {width, height} = canvasToSizeMap.get(canvas) || canvas;

      // Make sure it's valid for WebGPU
      width = Math.max(1, Math.min(width, device.limits.maxTextureDimension2D));
      height = Math.max(1, Math.min(height, device.limits.maxTextureDimension2D));

      // Only if the size is different, set the canvas size
      const needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        canvas.width = width;
        canvas.height = height;
      }
      return needResize;
    }

    function render() {
      resizeCanvasToDisplaySize(canvas);
      renderPassDescriptor.colorAttachments[0].view = context.getCurrentTexture().createView();

      const encoder = device.createCommandEncoder({label: 'our encoder'});

      const pass = encoder.beginRenderPass(renderPassDescriptor);
      pass.setPipeline(pipeline);

      pass.setBindGroup(0, bindGroup);
      pass.draw(3, 2);
      pass.end();

      const commandBuffer = encoder.finish();
      device.queue.submit([commandBuffer]);
    }


  }


  function fail(msg) {
    // eslint-disable-next-line no-alert
    alert(msg);
  }

  main();
</script>
</body>
</html>
